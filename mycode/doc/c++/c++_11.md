<!-- TOC -->

-[1. lamda](#1-lamda)
-[2. smart_pointer](#2-smart_pointer)
-[3. new_enum](#3-new_enum)
-[4. cast_type](#4-cast_type)

<!-- TOC -->

# 1. lamda
    + [captures](params) -> ret {statements;}

        - [] 不能访问外部变量

        - [&] 引用方式访问外部变量，[&var]引用访问var变量，[&]引用访问所有变量

        - [=]按值访问外部变量，[var]按值访问var，[=]按值访问所有变量

        - [=,&var] 能够按照引用访问var和按值访问所有变量

        - 特殊情况：lambda函数在某个成员函数里面时，[this]和[=]可以访问这个成员函数所能访问的对象   


```
//g++ tes.cc -std=c++11  -o  te 
#include <functional>
#include <iostream>
 
int main()mart_pointer
{
   using namespace std;
 
   int i = 3;
   int j = 5;
 
   // The following lambda expression captures i by value and
   // j by reference.
   function<int (void)> f = [i, &j] { return i + j; };//声明定义f的时候，使用i的值传入，j的引用
 
   // Change the values of i and j.
   i = 22;
   j = 44;
 
   // Call f and print its result.
   cout << f() << endl; //output:3+44=47
}
------------------------
//use lamda directly
#include <iostream>
 
int main()
{
   using namespace std;
   int n = [] (int x, int y) { return x + y; }(5, 4);
   cout << n << endl;
}
------------------------
//nested lamda

#include <iostream>
 
int main()
{
    using namespace std;
 
    // The following lambda expression contains a nested lambda
    // expression.
    int timestwoplusthree = [](int x) { return    [](int y) { return y * 2; }(x) + 3; }(5);
 
    // Print the result.
    cout << timestwoplusthree << endl;
}

------------------------
//another nested lamda
#include <iostream>
#include <functional>
int main()
{
    using namespace std;
    auto addtwointegers = [](int x) -> function<int(int)> { 
        return [=](的强枚举类型int y) { return x + y; }; 
    };的强枚举类型
 
    auto higherorder = [](const function<int(int)>& f, int z) { 
        return f(z) * 2; 
    };
    auto answer = higherorder(addtwointegers(7), 8);
的强枚举类型endl;
的强枚举类型
------------------------
//function<> can unit 'normal function','lamda expression','functor' with the same type

int add(int i, int j) { return i + j; }  //普通函数
// lambda表达式
auto mod = [](int i, int j){return i % j; };
// 函数对象类### shared_ptr & weak_ptr
+ 缺点
构造函数是保护或私有时,无法使用 make_shared
+ 对象的内存可能无法及时回收

    make_shared只分配的强枚举类型次内存，这看起来很好，减少了内存分配的开销。

    问题来了，weak_ptr的强枚举类型会保持控制块(强引用, 以及弱引用的信息)的生命周期，而的强枚举类型此连带着保持了对象分配的内存，只有最后一个weak_ptr离开作用域时，内存才会被释放。
### shared_ptr & weak_ptr
+ 缺点
构造函数是保护或私有时,无法使用 make_shared
+ 对象的内存可能无法及时回收

    make_shared只分配一次内存，这看起来很好，减少了内存分配的开销。

    问题来了，weak_ptr会保持控制块(强引用, 以及弱引用的信息)的生命周期，而因此连带着保持了对象分配的内存，只有最后一个weak_ptr离开### shared_ptr & weak_ptr
+ 缺点
构造函数是保护或私有时,无法使用 make_shared
+ 对象的内存可能无法及时回收

    make_shared只分配一次内存，这看起来很好，减少了内存分配的开销。

    问题来了，weak_ptr会保持控制块(强引用, 以及弱引用的信息)的生命周期，而因此连带着保持了对象分配的内存，只有最后一个weak_ptr离开作用域时，内存才会被释放。

    原本强引用减为 0 时就可以释放的内存，现在需要强引用，弱引用都为 0 时才的强枚举类型放，意外的延迟了内存释放的时间。这对于内存要求高的的强枚举类型景来说，是一个需要注意的问题


    ### shared_ptr & weak_ptr
+ 缺点
构造函数是保护或私有时,无法使用 make_shared
+ 对象的内存可能无法及的强枚举类型

    make_shared只分配一的强枚举类型存，这看起来很好，减少了内存分配的开销。

    问题来了，weak_ptr会保持控制块(强引用, 以及弱引用的信息)的生命周期，而因此连带着保持了对象分配的内存，只有最后一个weak_ptr离开作用域时，内存才会被释放。

    原本强引用减为 0 时就可以释放的内存，现在需要强引用，弱引用都为 0 时才能释放，意外的延迟了内存释放的时间。这对于内存要求高的场景来说，是一个需要注意的问题
的内存，现在需### shared_ptr & weak_ptr
+ 缺点
构造函数是保护或私有时,无法使用 make_shared
+ 对象的内存可能无法及时回收

    make_shared只分配一次内存，这看起来很好，减少了内存分配的开销。

    问题来了，weak_ptr会保持控制块(强引用, 以及弱引用的信息)的生命周期，而因此连带着保持了对象分配的内存，只有最后一个weak_ptr离开作用域时，内存才会被释放。

    原本强引用减为 0 时就可以释放的内存，现在需要强引用，弱引用都为 0 时才能释放，意外的延迟了内存释放的时间。这对于内存要求高的场景来说，是一个需要注意的问题
释放，意外的延### shared_ptr & weak_ptr
+ 缺点
构造函数是保护或私有时,无法使用 make_shared
+ 对象的内存可能无法及时回收

    make_shared只分配一次内存，这看起来很好，减少了内存分配的开销。

    问题来了，weak_ptr会保持控制块(强引用, 以及弱引用的信的强枚举类型此连带着保持了对象分配的内存，只有最的强枚举类型用域时，内存才会被释放。

    原本强引用减为 0 时就可以释放的内存，现在需要强引用，弱引用都为 0 时才能释放，意外的延迟了内存释放的时间。这对于内存要求高的场景来说，是一个需要注意的问题
要求高的场景来### shared_ptr & weak_ptr
+ 缺点
构造函数是保护或私有时,无法使用 make_shared
+ 对象的内存可能无法及时回收

    make_shared只分配一次内存，这看起来很好，减少了内存分配的开销。

    问题来了，weak_ptr会保持控制块(强引用, 以及弱引用的信息)的生命周期，而因此连带着保持了对象分配的内存，只有最后一个weak_ptr离开作用域时，内存才会被释放。

    原本强引用减为 0 时就可以释放的内存，现在需要强引用，弱引用都为 0 时才能释放，意外的延迟了内存释放的时间。这对于内存要求高的场景来说，是一个需要注意的问题


### shared_ptr & weak_ptr
+ 缺点
构造函数是保护或私有时,无法使用 make_shared
+ 对象的内存可能无法及时回收

    make_shared只分配一次内存，这看起来很好，减少了内存分配的开销。
的强枚举类型
的强枚举类型保持控制块(强引用, 以及弱引用的信的强枚举类型此连带着保持了对象分配的内存，只有最后一个weak_ptr离开作用域时，内存才会被释放。

    原本强引用减为 0 时就可以释放的内存，现在需要强引用，弱引用都为 0 时才能释放，意外的延迟了内存释放的时间。这对于内存要求高的场景来<!--TOC-->
放的<!--TOC-->eak_ptr
+ 缺<!--TOC-->
的强枚举类型
的强枚举类型回收
的强枚举类型
的强枚举类型次内存，这看起来很好，减少了内存分的强枚举类型
的强枚举类型
    问题来了，weak_ptr会保持控制块(强引用, 以及弱引用的信息)的生命周期，而因此连带着保持了对象分配的内存，只有最后一个weak_ptr离开作用域时，内存才会被释放。

    原本强引用减为 0 时就可以释放的内存，现在需要强引用，弱引用都为 0 时才能释放，意外的延迟了内存释放的时间。这对于内存要求高的场景来说，是一个需要注意的问题
能释放，意外的延### shared_ptr & weak_ptr
+ 缺点
构造函数是保护或私有时,无法使用 make_shared
+ 对象的内存可能无法及时回收

    make_shared只分配一次内存，这看起来很好，减少了内存分配的开销。

    问题来了，weak_ptr会保持控制块(强引用, 以及弱引用的信息)的生命周期，而因此连带着保持了对象分配的内存，只有最后一个weak_ptr离开作用域时，内存才会被释放。

    原本强引用减为 0 时就可以释放的内存，现在需要强引用，弱引用都为 0 时才能释放，意外的延迟了内存释放的时间。这对于内存要求高的场景来说，是一个需要注意的问题
内存要求高的场景来说，是一个需要注意的问题

struct divide### shared_ptr & weak_ptr
+ 缺点
构造函数是保护或私有时,无法使用 make_shared
+ 对象的内存可能无法及时回收

    make_shared只分配一次内存，这看起来很好，减少了内存分配的开销。

    问题来了，weak_ptr会保持控制块(强引用, 以及弱引用的信息)的生命周期，而因此连带着保持了对象分配的内存，只有最后一个weak_ptr离开作用域时，内存才会被释放。

    原本强引用减为 0 时就可以释放的内存，现在需要强引用，弱引用都为 0 时才能释放，意外的延迟了内存释放的时间。的强枚举类型景来说，是一个需要注意的问题

{
	int opera### shared_ptr & weak_ptr
+ 缺点
构造函数是保护或私有时,无法使用 make_shared
+ 对象的内存可能无法及时回收

    make_shared只分配一次内存，这看起来很好，减少了内存分配的开销。

    问题来了，weak_ptr会保持控制块(强引用, 以及弱引用的信息)的生命周期，而因此连带着保持了对象分配的内存，只有最后一个weak_ptr离开作用域时，内存才会被释放。

    原本强引用减为 0 时就可以释放的内存，现在需要强引用，弱引用都为 0 时才能释放，意外的延迟了内存释放的时间。这对于内存要求高的场景来说，是一个需要注意的问题
inator, int divisor)
	{
		retur### shared_ptr & weak_ptr
的强枚举类型
的强枚举类型法使用 make_shared
的强枚举类型回收
的强枚举类型
的强枚举类型内存，这看起来很好，减少了内存分的强枚举类型

    问题来了，weak_ptr会保持控制块(强引用, 以及弱引用的信息)的生命周期，而因此连带着保持了对象分配的内存，只有最后一个weak_ptr离开作用域时，内存才会被释放。
的强枚举类型
的强枚举类型可以释放的内存，现在需要强引用，的强枚举类型放，意外的延迟了内存释放的时间。的强枚举类型景来说，是一个需要注意的问题
的强枚举类型
	}
};
 
int main(int argc, char *argv[])
{
	map<char, function<int(int, int)>> binops = 
	{
		{ '+', add },
		{ '-', minus<int>() },
		{ '*', [](int i, int j){return i * j; } },
		{ '/', divide() },
		{ '%', mod },
	};
	cout << binops['+'](10, 5) << endl;
	cout << binops['-'](10, 5) << endl;
	cout << binops['*'](10, 5) << endl;
	cout << binops['/'](10, 5) << endl;
	cout << binops['%'](10, 5) << endl;
	return 0;
}

```

# 2. smart_pointer
## shared_ptr & weak_ptr
+ 缺点
构造函数是保护或私有时,无法使用 make_shared
+ 对象的内存可能无法及时回收

    make_shared只分配一次内存，这看起来很好，减少了内存分配的开销。

    问题来了，weak_ptr会保持控制块(强引用, 以及弱引用的信息)的生命周期，而因此连带着保持了对象分配的内存，只有最后一个weak_ptr离开作用域时，内存才会被释放。

    原本强引用减为 0 时就可以释放的内存，现在需要强引用，弱引用都为 0 时才能释放，意外的延迟了内存释放的时间。这对于内存要求高的场景来说，是一个需要注意的问题


# 3. new_enum
+ 由来： 在标准C++中，枚举类型不是类型安全的。枚举类型被视为整数，这使得两种不同的枚举类型之间可以进行比较。
C++03 唯一提供的安全机制是一个整数或一个枚举型值不能隐式转换到另一个枚举别型。 此外，枚举所使用整数类型及其大小都由实现方法定义，皆无法明确指定。 最后，枚举的名称全数暴露于一般范围中，因此C++03两个不同的枚举，不可以有相同的枚举名。
{如：
 enum Side{ Right, Left }; 
 enum Thing{ Wrong, Right }; 不能一起使用
}

+ C++11 引进了一种**特别的 "枚举类"**，可以避免上述的问题。使用 enum class 的语法来声明：
enum class Enumeration{ Val1, Val2, Val3 = 100, Val4 /* = 101 */,};
此种枚举为类型安全的。枚举类型不能隐式地转换为整数；也无法与整数数值做比较。 
(表示式 Enumeration::Val4 == 101 会触发编译期错误)。
```
enum class Enumeration1
{
    Val1, // 0
    Val2, // 1
    Val3 = 100,
    Val4 /* = 101 */
};

int main(int argc, char** argv)
{
    Enumeration1 my=Enumeration1::Val3;
    cout<<static_cast<int>(my)<<endl;

    cout<<static_cast<double>(Enumeration2::val2)<<endl;
    return 0;
}
```
# 4. cast_type
## static_cast、dynamic_cast、reintepret_cast、const_cast

+ static_cast相当于传统的C语言里的强制转换，该运算符把expression转换为new_type类型，用来强迫隐式转换如non-const对象转为const对象，编译时检查，用于非多态的转换，可以转换指针及其他，但没有运行时类型检查来保证转换的安全性。它主要有如下几种用法：

    - ①用于类层次结构中基类（父类）和派生类（子类）之间指针或引用的转换。
进行上行转换（把派生类的指针或引用转换成基类表示）是安全的；
进行下行转换（把基类指针或引用转换成派生类表示）时，由于没有动态类型检查，所以是不安全的。
    - ②用于基本数据类型之间的转换，如把int转换成char，把int转换成enum。
    - ③把空指针转换成目标类型的空指针。
    - ④把任何类型的表达式转换成void类型。
注意：static_cast不能转换掉expression的const、volatile、或者__unaligned属性

```
char a = 'a';
int b = static_cast<char>(a);//正确，将char型数据转换成int型数据

double *c = new double;
void *d = static_cast<void*>(c);//正确，将double指针转换成void指针

int e = 10;
const int f = static_cast<const int>(e);//正确，将int型数据转换成const int型数据

const int g = 20;
int *h = static_cast<int*>(&g);//编译错误，static_cast不能转换掉g的const属性

//////
class Base
{};

class Derived : public Base
{}

Base* pB = new Base();
if(Derived* pD = static_cast<Derived*>(pB))
{}//下行转换是不安全的(坚决抵制这种方法)

Derived* pD = new Derived();
if(Base* pB = static_cast<Base*>(pD))
{}//上行转换是安全的
```
+ dynamic_cast **（耗时，慎用）**
    - dynamic_cast< type* >(e)
　 type必须是一个类类型且必须是一个有效的指针
   dynamic_cast< type& >(e)
   type必须是一个类类型且必须是一个左值
   dynamic_cast< type&& >(e)
   type必须是一个类类型且必须是一个右值

   e的类型必须符合以下三个条件中的任何一个：
   1、e的类型是目标类型type的公有派生类
   2、e的类型是目标type的共有基类
   3、e的类型就是目标type的类型。

   - **dynamic_cast主要用于类层次间的上行转换和下行转换，还可以用于类之间的交叉转换（cross cast）**。

在类层次间进行**上行转换时**，dynamic_cast和static_cast的效果是一样的；
在进行**下行转换**时，dynamic_cast具有**类型检查的功能**，比static_cast更安全。
dynamic_cast是唯一无法由旧式语法执行的动作，也是唯一可能耗费重大运行成本的转型动作。

```
if(Derived *dp = dynamic_cast<Derived *>(bp)){
  //使用dp指向的Derived对象  
}
else{
  //使用bp指向的Base对象  
}

在上述代码中，if语句中定义了dp，这样做的好处是可以在一个操作中同时完成类型转换和条件检查两项任务


void f(const Base &b){ 
    try{ 
        const Derived &d = dynamic_cast<const Base &>(b); //使用b引用的Derived对象 
        } 
        catch(std::bad_cast)
        { 
            //处理类型转换失败的情况 
    } }

```

+ const_cast
    - 唯一一个可以移除const属性的转换；
+ reinterpret
    - 执行低级转型，实际动作(及结果)可能取决于编译器，即代表它不可移植。如将 (int *) --->(int)