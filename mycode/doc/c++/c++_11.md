### lamda
    + [captures](params) -> ret {statements;}

        - [] 不能访问外部变量

        - [&] 引用方式访问外部变量，[&var]引用访问var变量，[&]引用访问所有变量

        - [=]按值访问外部变量，[var]按值访问var，[=]按值访问所有变量

        - [=,&var] 能够按照引用访问var和按值访问所有变量

        - 特殊情况：lambda函数在某个成员函数里面时，[this]和[=]可以访问这个成员函数所能访问的对象   


```
//g++ tes.cc -std=c++11  -o  te 
#include <functional>
#include <iostream>
 
int main()
{
   using namespace std;
 
   int i = 3;
   int j = 5;
 
   // The following lambda expression captures i by value and
   // j by reference.
   function<int (void)> f = [i, &j] { return i + j; };//声明定义f的时候，使用i的值传入，j的引用
 
   // Change the values of i and j.
   i = 22;
   j = 44;
 
   // Call f and print its result.
   cout << f() << endl; //output:3+44=47
}
------------------------
//use lamda directly
#include <iostream>
 
int main()
{
   using namespace std;
   int n = [] (int x, int y) { return x + y; }(5, 4);
   cout << n << endl;
}
------------------------
//nested lamda

#include <iostream>
 
int main()
{
    using namespace std;
 
    // The following lambda expression contains a nested lambda
    // expression.
    int timestwoplusthree = [](int x) { return    [](int y) { return y * 2; }(x) + 3; }(5);
 
    // Print the result.
    cout << timestwoplusthree << endl;
}

------------------------
//another nested lamda
#include <iostream>
#include <functional>
int main()
{
    using namespace std;
    auto addtwointegers = [](int x) -> function<int(int)> { 
        return [=](int y) { return x + y; }; 
    };
 
    auto higherorder = [](const function<int(int)>& f, int z) { 
        return f(z) * 2; 
    };
    auto answer = higherorder(addtwointegers(7), 8);
    cout << answer << endl;
}
------------------------
//function<> can unit 'normal function','lamda expression','functor' with the same type

int add(int i, int j) { return i + j; }  //普通函数
// lambda表达式
auto mod = [](int i, int j){return i % j; };
// 函数对象类
struct divide
{
	int operator() (int denominator, int divisor)
	{
		return denominator / divisor;
	}
};
 
int main(int argc, char *argv[])
{
	map<char, function<int(int, int)>> binops = 
	{
		{ '+', add },
		{ '-', minus<int>() },
		{ '*', [](int i, int j){return i * j; } },
		{ '/', divide() },
		{ '%', mod },
	};
	cout << binops['+'](10, 5) << endl;
	cout << binops['-'](10, 5) << endl;
	cout << binops['*'](10, 5) << endl;
	cout << binops['/'](10, 5) << endl;
	cout << binops['%'](10, 5) << endl;
	return 0;
}

```


