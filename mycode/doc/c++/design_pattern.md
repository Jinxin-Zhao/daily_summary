<!-- TOC -->

- [创建型模式](#创建型模式)
  - [工厂方法模式](#工厂方法模式)
  - [抽象工厂模式](#抽象工厂模式)
    - [应用场景](#应用场景)
    - [优缺点](#优缺点)
      - [优点：](#优点)
      - [缺点](#缺点)
    - [与其他模式的关系](#与其他模式的关系)
  - [生成器模式](#生成器模式)
    - [问题引入](#问题引入)
      - [例子](#例子)
    - [解决方案](#解决方案)
      - [示例具体实现](#示例具体实现)
    - [应用场景](#应用场景-1)
    - [优缺点](#优缺点-1)
      - [优点](#优点-1)
      - [缺点](#缺点-1)
    - [与其他模式之间关系](#与其他模式之间关系)
  - [原型模式](#原型模式)
  - [单例模式](#单例模式)
- [结构型模式](#结构型模式)
- [行为模式](#行为模式)
  
<!-- TOC -->

# 创建型模式
## 工厂方法模式
## 抽象工厂模式
+ 抽象工厂定义了用于创建不同产品的接口，但将实际的创建工作留给了具体工厂类。每个工厂类都有对应一个特定的产品变体。
### 应用场景
+ 如果代码需要与多个不同系列的相关产品交互， 但是由于无法提前获取相关信息， 或者出于对未来扩展性的考虑， 你不希望代码基于产品的具体类进行构建， 在这种情况下， 你可以使用抽象工厂。
+ 抽象工厂为你提供了一个接口， 可用于创建每个系列产品的对象。 只要代码通过该接口创建对象， 那么你就不会生成与应用程序已生成的产品类型不一致的产品。
### 优缺点
#### 优点：
+ 你可以确保同一工厂生成的产品相互匹配。
+ 你可以避免客户端和具体产品代码的耦合。
+ 单一职责原则。 你可以将产品生成代码抽取到同一位置， 使得代码易于维护。
+ 开闭原则。 向应用程序中引入新产品变体时， 你无需修改客户端代码。
#### 缺点
+ 由于采用该模式需要向应用中引入众多接口和类， 代码可能会比之前更加复杂。

### 与其他模式的关系
+ 生成器重点关注如何分步生成复杂对象。 抽象工厂专门用于生产一系列相关对象。 抽象工厂会马上返回产品， 生成器则允许你在获取产品前执行一些额外构造步骤。




## 生成器模式
+ 生成器模式是一种创建型设计模式， 使你能够分步骤创建复杂对象。 该模式允许你使用相同的创建代码生成不同类型和形式的对象。
### 问题引入
+ 假设有这样一个复杂对象， 在对其进行构造时需要对诸多成员变量和嵌套对象进行繁复的初始化工作。 这些初始化代码通常深藏于一个包含众多参数且让人基本看不懂的构造函数中； 甚至还有更糟糕的情况， 那就是这些代码散落在客户端代码的多个位置。 而如果为每种可能的对象都创建一个子类，这可能会导致程序变得过于复杂。
#### 例子
+ 例如， 我们来思考如何创建一个 房屋House对象。 建造一栋简单的房屋， 首先你需要建造四面墙和地板， 安装房门和一套窗户， 然后再建造一个屋顶。 但是如果你想要一栋更宽敞更明亮的房屋， 还要有院子和其他设施 （例如暖气、 排水和供电设备）， 那又该怎么办呢？
最简单的方法是扩展 房屋基类， 然后创建一系列涵盖所有参数组合的子类。 但最终你将面对相当数量的子类。 任何新增的参数 （例如门廊类型） 都会让这个层次结构更加复杂。
另一种方法则无需生成子类。 你可以在 房屋基类中创建一个包括所有可能参数的超级构造函数， 并用它来控制房屋对象。 这种方法确实可以避免生成子类， 但它却会造成另外一个问题。
    ```cpp
    class House{
        House(windows,doors,rooms,hasGarage,hasSwimPool,hasStatues,hasGarden, ...)
    }

    auto * pH1 = new House(4,2,3,true,NULL,NULL,NULL, .....);
    auto * pH2 = new House(4,2,3,true,true,true,true, .....);
    ```
+ 绝大部分的参数都没有使用， 这使得对于构造函数的调用十分不简洁。 例如， 只有很少的房子有游泳池， 因此与游泳池相关的参数十之八九是毫无用处的。

### 解决方案
+ 生成器模式建议将对象构造代码从产品类中抽取出来， 并将其放在一个名为生成器的独立对象中。生成器模式让你能够分步骤创建复杂对象。 生成器不允许其他对象访问正在创建中的产品。
+ 该模式会将对象构造过程划分为一组步骤， 比如 build­Walls创建墙壁和 build­Door创建房门创建房门等。 每次创建对象时， 你都需要通过生成器对象执行一系列步骤。 重点在于你无需调用所有步骤， 而只需调用创建特定对象配置所需的那些步骤即可。
+ 当你需要创建不同形式的产品时， 其中的一些构造步骤可能需要不同的实现。 例如， 木屋的房门可能需要使用木头制造， 而城堡的房门则必须使用石头制造。
在这种情况下， 你可以创建多个不同的生成器， 用不同方式实现一组相同的创建步骤。 然后你就可以在创建过程中使用这些生成器 （例如按顺序调用多个构造步骤） 来生成不同类型的对象。
+ 你可以进一步将用于创建产品的一系列生成器步骤调用抽取成为单独的主管类。 主管类可定义创建步骤的执行顺序， 而生成器则提供这些步骤的实现。严格来说， 你的程序中并不一定需要主管类。 客户端代码可直接以特定顺序调用创建步骤。 不过， 主管类中非常适合放入各种例行构造流程， 以便在程序中反复使用。
+ 此外， 对于客户端代码来说， 主管类完全隐藏了产品构造细节。 客户端只需要将一个生成器与主管类关联， 然后使用主管类来构造产品， 就能从生成器处获得构造结果了。

#### 示例具体实现
+ 汽车是一个复杂对象， 有数百种不同的制造方法。如果客户端代码需要组装一辆与众不同、 精心调教的汽车， 它可以直接调用生成器。 或者， 客户端可以将组装工作委托给主管类， 因为主管类知道如何使用生成器制造最受欢迎的几种型号汽车。
+ 你或许会感到吃惊， 但确实每辆汽车都需要一本使用手册。使用手册会介绍汽车的每一项功能， 因此不同型号的汽车， 其使用手册内容也不一样。 因此， **你可以复用现有流程来制造实际的汽车及其对应的手册**。当然， 编写手册和制造汽车不是一回事， 所以我们需要另外一个生成器对象来专门编写使用手册。 该类与其制造汽车的兄弟类都实现了相同的制造方法， 但是其功能不是制造汽车部件， 而是描述每个部件。 将这些生成器传递给相同的主管对象， 我们就能够生成一辆汽车或是一本使用手册了。
+ 最后一个部分是获取结果对象。 尽管金属汽车和纸质手册存在关联， 但它们却是完全不同的东西。 我们无法在主管类和具体产品类不发生耦合的情况下， 在主管类中提供获取结果对象的方法。 因此， 我们只能通过负责制造过程的生成器来获取结果对象。

### 应用场景
+ 使用生成器模式可以避免“重叠构造函数(telescopic constructor)”的出现。假设你的构造函数中有十个可选参数， 那么调用该函数会非常不方便； 因此， 你需要重载这个构造函数， 新建几个只有较少参数的简化版。 但这些构造函数仍需调用主构造函数， 传递一些默认数值来替代省略掉的参数。
  ```cpp
  class Pizza {
    Pizza(int size) { ... }
    Pizza(int size, boolean cheese) { ... }
    Pizza(int size, boolean cheese, boolean pepperoni) { ... }
  ```
+ 生成器模式让你可以分步骤生成对象， 而且允许你仅使用必须的步骤。 应用该模式后， 你再也不需要将几十个参数塞进构造函数里了。

+ **使用生成器构造组合树或其他复杂对象**
生成器模式让你能分步骤构造产品。 你可以延迟执行某些步骤而不会影响最终产品。 你甚至可以递归调用这些步骤， 这在创建对象树时非常方便。
生成器在执行制造步骤时， 不能对外发布未完成的产品。 这可以避免客户端代码获取到不完整结果对象的情况。

### 优缺点
#### 优点
+ 你可以分步创建对象， 暂缓创建步骤或递归运行创建步骤。
+ 生成不同形式的产品时， 你可以复用相同的制造代码。
+ 单一职责原则。 你可以将复杂构造代码从产品的业务逻辑中分离出来。
#### 缺点
+ 由于该模式需要新增多个类， 因此代码整体复杂程度会有所增加。
### 与其他模式之间关系
+ 抽象工厂、 生成器和原型都可以用单例模式来实现。



## 原型模式

## 单例模式
+ Eager Singleton:

  ```cpp
  template <typename T>
  class EagerSingleton {
    private:
      static T * _t;
    public:
      static T & GetInstance() {
        return *_t;
      }
      EagerSingleton(T&&) = delete;
      EagerSingleton(const T &) = delete;
      void operator= (const T &) = delete;
    protected:
      EagerSingleton() = default;
      virtual ~EagerSingleton = default;
  };

  template <typename T>
  T * EagerSingleton<T>::_t = new (nothrow) T;
  ```
+ boost的实现：
  ```cpp
  template <typename T>
  struct singleton_default {
    private:
      struct object_creator {
        object_creator() {
          singleton_default<T>::instance();
        }
        inline void do_nothing() const {}
      };
    static object_creator creat_object;

    singleton_default();

  public:
    typedef T object_type;
    
    static object_type & instance() {
      static object_type obj;
      create_object.do_nothing();
      return obj;
    }
  };

  template <typename T>
  typename singleton_default<T>::object_creator
  singleton_default<T>::create_object;
  ```

# 结构型模式
# 行为模式