<!-- TOC -->

- [1. block anatomy](#1-block-anatomy)
  - [Field Definition](#field-definition)
    - [locktime](#locktime)
- [零知识证明](#零知识证明)
- [混币服务](#混币服务)
- [比特币手续费收取规则](#比特币手续费收取规则)
- [元宇宙](#元宇宙)
- [反洗钱分类](#反洗钱分类)
  - [Dark Market](#dark-market)
  - [Mixing Services](#mixing-services)
  - [ponzi Scheme](#ponzi-scheme)
- [2. web3 blockchain](#2-web3-blockchain)
  - [web3 Protocol](#web3-protocol)
- [DAO](#dao)
- [ETH](#eth)
      - [EOA \& CA](#eoa--ca)
      - [gasless](#gasless)
        - [Token](#token)
      - [我们项目的最终目的（先从Blur Token入手，后续加入之前所列出Token）：](#我们项目的最终目的先从blur-token入手后续加入之前所列出token)
      - [问题：](#问题)
  - [](#)



<!-- TOC -->

# 1. block anatomy
![avatar](block_png/block_anatomy.png)

## Field Definition

<font color=blue size=5>block</font>
| size(byte) | field_name | data type | description |
| ------ | ------ | ------ | ------ |
| 4 | magic no | uint32 | 总是0xD9B4BEF9,作为区块之间的分隔符 |
| 4 | block size |  uint32 | 后面数据到块结束的字节数 |
| 80 | block header | char[] | block header |
| varies | tx count | uint | 交易数量 |
| varies | transaction | char[] | 交易数据详情 |

<font color=blue size=5>block header</font>
| size(byte) | field_name | data type | description |
| ------ | ------ | ------ | ------ |
| 4 | version |  int32_t | 版本号 |
| 32 | hashpreblock | char[32] | 前一个block的hash值 |
| 32 | hashmerkleroot | char[32] | 区块内所有交易的merkle hash值 |
| 4 | time | uint32 | unix时间戳，矿工挖矿的时间 |
| 4 | bits | uint32 | 该块的标题hash必须小于的值。难度 |
| 4 | nonce | uint32 | 随机值，用于产生满足难度的hash值 |

<font color=blue size=5>transaction</font>
| size(byte) | field_name | data type | description |
| ------ | ------ | ------ | ------ |
| 4 | version | uint32 | 交易版本号 |
| varint | tx_in counter | uint | 交易输入数量 |
| varies | list of inputs | tx_in | 交易输入 |
| varint | out counter | uint | 交易输出数量 |
| varies | list of outputs | tx_out | 交易输出 |
| 4 | lock time | uint32 | 锁定时间 |

<font color=blue size=5>input</font>
| size(byte) | field_name | data type | description |
| ------ | ------ | ------ | ------ |
| 32 | pre tx hash | outpoint | 前置交易hash |
| 4 | pre txout index | uint32 | 前置交易index |
| varint | txin script len |  uint | 解锁脚本长度 |
| varies | scriptsig | char[] | 解锁脚本 |
| 4 | sequence no | uint32 | 序列号 |

<font color=blue size=5>output</font>
| size(byte) | field_name | data type | description |
| ------ | ------ | ------ | ------ |
| 8 | value | int64 | 花费的数量，单位是聪 |
| 1+ | txout script len | uint | pubkey脚本中的字节数量 |
| varies | scriptpubkey | char[] | 花费这笔输出需要满足的条件 |

### locktime
+ <font size=5>**lock_time**</font>是一个多意字段，表示在某个高度的Block之前或某个时间点之前该交易处于锁定态，无法收录进Block。
+ 当**Input**中的<font color=green size=5>sequence No</font>字段被置为[**0xffffffff**]，表示发送方不会再修改这个交易了，lock_time也被忽略，交易会被直接打包。也就是发送方不会再把tx_vin拿去发给别人。很多时候locktime是为了发送方在locktime前可以改变主意，当发送方不会改变主意后。

| value(lock time) | definition | 
| ------ | ------ |
| 0 | 立即生效 |
| < 500000000 | 含义为Block高度，处于该Block之前为锁定(不生效) |
| >= 500000000 | 含义为Unix时间戳，处于该时刻之前为锁定(不生效) |

![avatar](block_png/block_field.png)

# 零知识证明
+ 零知识证明(Zero—Knowledge Proof) 是由S.Goldwasser、S.Micali及C.Rackoff在20世纪80年代初提出的。它早于区块链诞生，但由于区块链，它被大家所熟知。它指的是证明者能够在不向验证者提供任何有用的信息的情况下，使验证者相信某个论断是正确的。
零知识证明可以分为交互式和非交互式两种：
    - 交互式：零知识证明协议的基础是交互式的。它要求验证者不断对证明者所拥有的“知识”进行一系列提问。证明者通过回答一系列问题，让验证者相信证明者的确知道这些"知识"。然而，这种简单的方法并不能使人相信证明者和验证者都是真实的，两者可以提前串通，以便证明者可以在不知道答案的情况下依然通过验证。

    - 非交互式：非交互式零知识证明不需要交互过程，避免了串通的可能性，但是可能需要额外的机器和程序来确定实验的顺序。
+ 通俗的来讲，就是既证明了自己想证明的事情，同时透露给验证者的信息为"零"。
  比如：用户在系统注册时，系统不会保存用户的密码明文，而是保存了密码的哈希值；用户在登录系统时，只需要输入注册时的密码，系统会根据用户输入密码产生的哈希值与系统数据库保存的哈希值进行比对。如果一致，则系统认为当前登录用户知道该账号的密码。



# 混币服务
+ 混币服务的原理是什么？

混币服务本质就是用一种加密货币从其他人那里得到同样金融的加密货币，分离交易中的输入和输出地址，一个交易中包括大量输入和输出，很难在输入和输出中找出每个人的对应交易对，输入与输出之间的联系被事实上割裂。
混币服务分为中心化和去中心化服务：
- 中心化服务：这种比特币混币的优点是用户无需担心交易的复杂性，只需输入比特币地址，加入混币即可，但是也有中心化风险。比如：MixerTumbler，GramShelix，BitcoinFog 等
- 去中心化混币服务：在这种混合模式中，不同的用户组成一个交易所并使用协议进行有效地混币，这种混币的优点是没有中间人，没有中间机构监管这些交易。比如：CoinJoin，SharedCoin 和 CoinSwap 等。

# 比特币手续费收取规则
+ 可用金额叫做交易的“输入”，最终发送金额（包括退回到钱包的找零）称为“输出”。若交易“输出”（包括找零）小于0.01BTC，则收取0.0001BTC的手续费。 “选币”时，算法会尽量避开那些找零金额低于0.01BTC的币。
+ 数额越大、币龄越高优先级越高。如果你发送金额太小或者是你的比特币刚开采出来不久，那么你的转账就不再免费之列。每一个交易都会分配一个优先级，这个优先级通过币的新旧程度、交易的字节数和交易的数量。具体来说，对于每一个输入（inputs）来讲，客户端会先将比特币的数量乘以这些币在块中存在的时间（币龄，age），然后将所有的乘积加起来除以此次交易的大小（以字节为单位）。如果你确实大量的小额输入，又想免费转出，这时候你可以加一个数额大的、币龄大的比特币金额，就会将平均优先级提高，从而可以免费转出比特币。
+ 每千字节的收费： 每千字节的收费在转账的最后客户端会检测本次转账的大小（以字节为单位），大小一般取决于输入和输出的数额大小，计算公式如下：148 * 输入数额 + 34 * 输出数额 + 10，如果该次转账的大小超过10000字节但是优先级符合免费的标准，那么仍然可以享受免费转账，否则需要支付手续费。没1000字节的费用默认是0.0001BTC，但是你也可以在客户端里进行追加，依次打开选项卡“设置>选项>主要”进行手续费的调整。如果你在设置的手续费小于0.0001BTC按0.0001算。当本条规则适用时将会取代步骤2的规则而不是累加。


# 元宇宙
+ VR眼睛是一个不可或缺的桥梁能够连接现实世界和虚拟世界。
+ NFT的价值并不是现在静态的投机性质的NFT，而是具有一定的增长性质的用户有投入的一个产品，比如清明上河图里面用户拿到的都是一些木板，然后参与搭建自己的独特的建筑（类似于区块链的Proof of work），成品可进行转让。
+ 元宇宙里虚拟的自我映射，可以通过类似于人工智能的打标签手段不断矫正它的行为，使其更像是自己，这样能够得到永生。

+ 构建元宇宙需要区块链、游戏、网络算力、VR四大技术支撑。NFT就是区块链中的一环。

# 反洗钱分类
## Dark Market
+ 比特币是黑市交易主要的支付货币之一。黑市交易累积掌控着大量的比特币地址。
## Mixing Services

## ponzi Scheme

小样本、GNN

公式：
原始问题、推到、目标函数优化
图片：



# 2. web3 blockchain
## web3 Protocol
+ web3 protocol主要由三个角色组成：web3用户、服务提供商、区块链维护者。web3用户是数据拥有者，同时也可以发送交易请求；服务提供商给用户提供链上接口，同时处理请求和区块链平台交互。区块链维护者提供一个智能合约的操作环境（处理业务和数据存储）
+ Web3应用程序共享的最主要原则是用户可以完全控制数据，包括标识符/令牌/所有权等。
+ web3开发人员不需要在单个服务器或数据库之上构建应用程序。相反web3应用程序部署在去中心化网络上，例如区块链平台或由许多对等(P2P)服务器托管的相关分布式系统。

# DAO
+ DAO(Decentralized Autonomous  Corporations),去中心化自治组织。大多是DAO依赖于区块链技术和智能合约，他们是在区块链上运行的代码集合。

# ETH
+ 交易回执(Recipt),表示交易的最终状态。
  - status：执行结果，1表示成功，0表示失败；
  - gasUsed：已消耗的Gas数量；
  - txHash：交易Hash；
  - logs：交易产生的日志；
  - ……
+ 转账交易，转账交易是指两个外部账号转移Ether，我们以测试网的交易0xf04d...b7ba为例，可以看到：
  - Transaction Hash: 0xf04d...b7ba，这是交易Hash，即交易的唯一标识；
  - Status: Success，表示交易成功；
  - From: 0x0c46...2978，交易的发送方；
  - To: 0x77e4...e34c，交易的接收方；
  - Value: 0.02759796846726396 Ether，交易发送的Ether；
  - Gas Price: 1.500000788 Gwei，Gas的价格；
  - Gas Limit: 21,000，转账交易恰好消耗21000Gas，因此总是21000；
  - Gas Used by Transaction: 21,000 (100%)，消耗的Gas占比，这里恰好全部消耗完；
  - Nonce：1，发送方的nonce，1表示第2笔交易；
  - Input Data: 0x，因为是转账交易，没有输入数据，因此为空。
+ 合约交易，合约交易就是指一个外部账号调用某个合约的某个public函数。我们以测试网的交易0x2235...132e为例，可以看到：
  - From: 0x0c46...2978，交易的发起方，该地址一定是外部账户；
  - To: 0x5b2a...5a46，交易的接收方，这里地址是一个合约地址；
  - Value: 0 Ether，这里发送的Ether是0，即没有向合约发送Ether；
  - Gas Limit: 105,406，这是交易发起前设定的最大Gas；
  - Gas Used by Transaction: 70,271 (66.67%)，这是交易实际消耗的Gas；
  - Input Data: 0xb3f98adc...，这是交易的输入数据，其中包含了调用哪个函数，以及传递的参数。

#### EOA & CA
+ EOA 的另一个设定是作为交易的发起方并支付 gas，相对应的 CA（合约账户）只能被其他 CA 或者 EOA 调用。也就是说，EOA 是交易的触发器，一笔交易无论后面有多少合约调用，一开始都必须由一个 EOA 发起并且支付足够的 gas 才可以进行。
  CA（Contract Accounts）中文叫做合约账户（也曾被称为内部账户），我们常见的 ERC-20 代币合约、DeFi 业务合约等都有一个跟 EOA 长得很像的地址，这就是 CA。
在设定上，CA 是以太坊世界的原住民，EOA 和 ETH 是为 CA 的业务逻辑准备的触发器和燃料；实际使用下来，以太坊上除 ETH 之外的所有资产都是由 CA 承载，DeFi 等业务逻辑就更是全都由 CA 来实现。简单来说，CA 是具备内部逻辑的以太坊账户，里面既可以是业务逻辑（Token 合约用来记账，质押合约用来放贷和清算），也可以是账户逻辑（比如 gnosis safe 的多签逻辑），而后者就是我们即将提到的「SCW - 智能合约钱包」概念。
CA 的地址规则是通过计算生成的，有 CREATE 和 CREATE2 两种方式，这里不再展开。大家只需要记住 CA 和公钥没有必然对应关系即可，比如 gnosis safe 创建的 CA 里可以设定任意多把公钥来解锁它的地址对应的资产；当然 CA 也可以不设定任何密钥，而是由其他 CA 的逻辑决定是否可以解锁，比如 DeFi 的借贷合约，只要还了钱就能取回质押的资产。
#### gasless
+ 这里的 gas 指的是 gas fee，所以 gasless 的意思是「免 gas fee 的」。同样的，gasless 也不是真的不需要支付 gas fee，而是指用户不需要被迫去了解 gas 概念，更不用提前购买各种原生代币来支付 gas。

那么 gas 谁来付？分两种情况：

1. 一种是用户账户里已经有 crypto asset 的时候，比如 play to earn 得到 token，或者领到的空投，亦或是别人的转账，只要这些 token 有一定的价值和流动性，就会有 relayer 愿意接受它们并帮用户支付 gas，以此赚取收益

2. 另一种是用户账户里没有有价 token，比如刚刚创建的账户。如果此时需要链上交互，应用方可以选择资助用户一些「定向」用途的 gas 来帮他们 bootstrap，从而降低用户流失，这时即便算上 gas 补贴的消耗，整体的用户获取成本反而可能会更低；或者可以通过让用户观看广告等方式来换取一些 gas。

这两种策略在 gas 成本较低的 L2 上都非常有效。


##### Token
Native Token --> Option Token

现有区块链项目代币的分配方式

白皮书看多了就会发现，大多数项目在代币分配方面的计划如出一辙。有以下几个特点：

    Token 总量恒定 - 这是沿袭了比特币的总量恒定的特点；

    10%-20% 留给团队；10%-20% 留给基金会；30%-60% 私募/公开销售；

    在项目正式开始运作前就把代币全部“预售”掉了；

这种分布方式有它行程的历史原因，可以理解，比如总量恒定就是沿袭了比特币总量2100万的传统。但是显然这种分配方式的弊端也非常明显，主要弊端有以下几点：

1、总量恒定意味着会产生“通货紧缩”，单位token的价格会不断上升，其实这是非常不利于token在应用场景下流转的，到时炒币的关键所在。

2、总量恒定还意味着永远没有在”二级市场增发”的机会，项目在第一次募资的时候就必须把全生命周期的资金募集到位，这对于一个初创型企业来说也是很不合理的事情。  

3、 在项目正式开始运作前就把代币全部“预售”掉了相当于一个初创企业在刚创业的时候就把所有股份“贱卖”了。

二、新型代币分配方式的探讨

1、总量无需恒定，可采用每年均速增发的方式；

2、总量恒定，但在第一次销售时仅销售10%-20%的代币，其余代币保留至后期销售。



 
#### 我们项目的最终目的（先从Blur Token入手，后续加入之前所列出Token）： 
+ 找出所列四种类别(investor,Community Growth, Developer,Employee)的所有holders并统计各自类别持有token对总供应量的占比。
#### 问题：
+ Q1： Blur Distribution在网站上(https://docs.blur.foundation/tokenomics)已有公布四类(investor[19%],community[51%],contributors[29%],advisors[%1]),网站中公布的占比情况前两种是和我们项目所列出的类别吻合，针对Blur是不是可以认为我们只需要找出我们想要的Developer(和网站的contributors是否是同类)和Employee类别？
+ Q2: 因为了解到每个Token在TGE后项目方都会公布相应的代币经济模型，如BNB公布的三种类型：(Funding team: 40%,对应employee?),(Angel investors: 10%),(Public sale: 50%)。和Blur的分配对象类别不同，还有另一个代币CyberConnect(https://www.bitpush.news/articles/4159685),相比BNB和Blur类别更丰富。我们的项目是不是不管哪种Token，都是按照我们自己定义的这四类(investor,Community Growth, Developer,Employee)来统计？
+ Q3：了解到Token的分配方案很多都是有时间段的（比如29%的Blur分配给investor按为期4年分配，在前4个月有转移额度解锁），我们想要统计的上述四种持有代币对象类别所持有的Token数目占比的统计时间区间怎么确定？
+ Q4: 我们定义的这几种类别之间关系是否是独立的，contributors有没有可能同时也是investor，或者四种类别之间有其他某种联系？
+ Q5：在基于Token数据画出交易流图后，我们项目有没有对四种类别详细的定义，然后我们可以根据一些特征比如airdrop每一批的单笔转账amount肯定不会太大，不会超过某个上界，那如何区分airdrop和employee的转账，因为两者都具有批量转账特性，airdrop和employee的交易图表现出来就是有某一地址节点的出度比较大，散布给其他不同的节点。（这里有没有可能给investor和employee转账的时候都是调用的是空投智能合约？Airdrop智能合约是否只是这两个类别分配token的一种调用方式，简而言之就是空投的对象其实可能既是employee也可能是investor）

## 
+ 数据规模，标签数据(CA地址标签、类别标签)。
+ 主线思路。


代币账户种类：
投资者： 以太坊上的代币经济学的投资者定义是指那些在以太坊网络上投资和交易代币的个人或机构。这些投资者通过购买代币来参与项目的经济体系，并期望通过代币的升值或其他经济激励机制获得回报。

代币经济学是指针对特定代币设计的经济体系，其中包括供应量、通胀率、通缩机制、奖励机制、流通性等因素。投资者在参与代币经济学时通常会考虑这些因素，以评估代币的潜在价值和投资回报。

以太坊是一个智能合约平台，允许开发者创建和部署基于区块链技术的去中心化应用（DApps），并发行代币作为应用的经济激励和交易媒介。以太坊上的代币经济学投资者可能包括早期投资者、风险投资基金、机构投资者、交易所用户等，他们参与购买代币的目的可以是长期投资、短期交易或参与特定项目的治理和社区建设等。

投资者对于代币经济学的定义可能因个人或机构的目标和策略而有所不同。一些投资者可能更关注代币的技术特性、应用场景和团队背景，而另一些投资者可能更注重短期市场走势和交易机会。总之，代币经济学的投资者定义是那些在以太坊上参与代币经济体系的个人或机构，他们通过购买代币来寻求投资回报和参与区块链项目的发展。

社区用户：以太坊上的代币经济学的社区用户是指那些积极参与和贡献于特定代币项目社区的个人或群体。他们与该代币项目的共同兴趣、目标或价值观相关联，并通过参与社区活动、贡献内容和资源、提供技术支持等方式来建立联系和共享知识。
//////////////////
代币经济学的社区用户在以太坊上的代币项目中扮演着重要的角色，他们可能包括但不限于以下类型的人：

持有者和投资者：购买和持有代币作为长期投资，参与代币的经济体系，并期望通过代币的升值或其他经济激励机制获得回报。
开发者和技术贡献者：参与代币项目的开发、编写智能合约代码、提供技术支持和安全审计等方面的贡献。
社交媒体参与者：积极参与社交媒体平台上的讨论、分享代币项目的信息、提供反馈和建议等。
治理参与者：参与代币项目的治理过程，包括投票、提案和决策，以影响代币经济学的发展和方向。
内容创作者和影响者：撰写文章、发布视频、举办活动等，以宣传和推广代币项目，吸引更多用户和投资者参与。
教育者和支持者：为代币项目提供教育资源、解答问题、提供支持和指导，帮助新用户理解和使用代币。
代币经济学的社区用户通过积极参与代币项目的社区生态系统，共享知识、建立联系和合作，促进代币项目的发展和推广。他们的参与和贡献可以增加代币的认可度、社区的活跃度，同时也有助于构建一个健康、繁荣的代币经济体系。

//////////////////
代币经济学的开发者有时会进行代币交易，但这取决于个人的选择和情况。以下是一些可能出现在代币经济学开发者交易行为中的特征：

提供流动性：开发者可能会提供代币的流动性，例如将代币添加到去中心化交易所（DEX）或其他流动性池中，以便用户可以进行交易。
奖励和薪酬：作为对开发者贡献的回报，项目可能会向开发者支付代币作为奖励或薪酬。这些代币可以在某些情况下被开发者交易或出售。
技术测试和验证：开发者可能会在测试和验证代币经济模型时进行一些交易行为，以确保代币合约和经济机制的正确性和有效性。
参与代币销售：在代币项目的初始阶段，开发者可能会参与代币的私募或公开销售，以获得项目发展的初期资源和支持。
市场投资和交易：一些开发者可能会将代币视为投资机会，并在市场上进行买卖交易，以追求投资回报或进行风险管理。
长期持有：作为对代币项目的承诺，一些开发者可能会长期持有代币，以表明对项目的支持，并与代币项目的成功和发展相连。

///// LSTM
LSTM（长短期记忆网络）是一种常用的循环神经网络（RNN）架构，它可以有效地处理序列数据。在LSTM中，输入和输出的格式与传统的神经网络不同，需要一些特殊的处理。

LSTM的输入格式通常是一个三维张量，形状为（samples，timesteps，features）。其中，samples表示数据集中的样本数量，timesteps表示每个样本的时间步数，features表示每个时间步的特征数。比如，如果我们要对一个文本序列进行情感分类，可以把每个单词表示成一个向量，然后把整个句子表示成一个二维矩阵，将多个句子组成一个三维张量。假设我们有1000个句子，每个句子有20个单词，每个单词表示成一个长度为50的向量，那么输入数据的形状就是（1000，20，50）。

LSTM的输出格式也是一个三维张量，形状同样为（samples，timesteps，features）。通常情况下，我们只关心LSTM最后一个时间步的输出，即最后一个隐藏状态（也可以选择关心每个时间步的输出）。如果我们的任务是分类，那么可以把最后一个隐藏状态作为全连接层的输入，输出类别概率。如果我们的任务是回归，那么可以直接用最后一个隐藏状态的值作为预测值。

总之，LSTM的输入输出格式与传统神经网络不同，需要按照三维张量的格式处理数据。同时，需要注意选择合适的隐藏状态作为输出，以便进行下一步的任务。


/////// 多分类衡量指标
用于衡量多分类问题的指标有多种，以下是其中几个常用的指标：

准确率（Accuracy）：准确率是最简单直观的评估指标，表示分类正确的样本数占总样本数的比例。然而，当类别不平衡或者误差代价不同时，准确率可能不足以准确评估模型的性能。

混淆矩阵（Confusion Matrix）：混淆矩阵是一种展示分类模型预测结果的矩阵，可以计算出多个指标，如真正例（True Positives, TP）、真负例（True Negatives, TN）、假正例（False Positives, FP）、假负例（False Negatives, FN）等。

精确率（Precision）和召回率（Recall）：精确率表示模型预测为正例中真正为正例的比例，召回率表示真正为正例中被模型正确预测为正例的比例。精确率和召回率常常在二分类问题中使用，但可以通过宏平均（Macro-average）或微平均（Micro-average）的方式扩展到多分类问题。

F1值（F1-Score）：F1值是精确率和召回率的调和平均，综合考虑了分类模型的准确性和完整性。F1值常用于评估分类模型在不同类别上的综合性能，尤其是在类别不平衡的情况下。

Log Loss：对于概率预测模型，如逻辑回归或神经网络，可以使用对数损失（Log Loss）作为评估指标。对数损失衡量了模型预测的概率与真实标签之间的差异，数值越小表示模型的预测越准确。

ROC曲线和AUC：对于多分类问题，可以将ROC曲线和AUC（多类别AUC）扩展到多类别评估。ROC曲线绘制了不同类别之间的真正例率和假正例率关系，AUC表示ROC曲线下的面积，用于衡量模型的整体性能。